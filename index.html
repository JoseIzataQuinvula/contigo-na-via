<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contigo na Via - Mototáxi App</title>
    <!-- Tailwind CSS para design responsivo e moderno -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Configuração da fonte Inter (padrão) -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
        }
        #map-simulation {
            height: 100vh;
            width: 100%;
        }
        .overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 1.5rem;
            border-top-left-radius: 1.5rem;
            border-top-right-radius: 1.5rem;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1);
            z-index: 100;
            transform: translateY(0);
            transition: transform 0.3s ease-in-out;
        }
        .overlay.hidden {
            transform: translateY(100%);
            pointer-events: none;
        }
        .input-container {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0.75rem;
            background-color: #f0f0f0;
            border-radius: 0.75rem;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        .icon-pin { color: #22c55e; } /* Verde para Origem */
        .icon-pin-end { color: #ef4444; } /* Vermelho para Destino */
    </style>
    <!-- Google Material Symbols para ícones -->
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
</head>

<body class="overflow-hidden">

    <div id="app-container" class="relative min-h-screen">

        <!-- Header -->
        <header class="app-header bg-white shadow-md p-4 flex justify-between items-center w-full absolute top-0 z-50">
            <button id="menu-icon" class="text-gray-600 hover:text-red-600 transition-colors">
                <span class="material-symbols-outlined">menu</span>
            </button>
            <h1 class="app-title text-xl font-bold text-gray-800">Contigo na Via</h1>
            <button id="profile-icon" class="text-gray-600 hover:text-red-600 transition-colors">
                <span class="material-symbols-outlined">person</span>
            </button>
        </header>

        <main id="main-screen">
            <!-- Simulação do Mapa -->
            <div id="map-simulation"></div>

            <!-- Overlay de Busca (Tela 1) -->
            <div id="search-overlay" class="overlay">
                <p id="auth-status" class="text-sm text-gray-500 mb-4"></p>
                <div class="input-container">
                    <span class="material-symbols-outlined icon-pin mr-3">fiber_manual_record</span>
                    <input type="text" id="input-origem" value="Carregando sua Localização..." readonly
                        class="bg-transparent w-full focus:outline-none placeholder-gray-500 text-gray-700">
                </div>
                <div class="input-container">
                    <span class="material-symbols-outlined icon-pin-end mr-3">location_on</span>
                    <input type="text" id="input-destino" placeholder="Para onde vamos, Contigo na Via?"
                        class="bg-transparent w-full focus:outline-none placeholder-gray-500 text-gray-700">
                </div>

                <button id="btn-chamar"
                    class="w-full primary-button mt-4 flex items-center justify-center space-x-2 bg-red-600 text-white py-3 rounded-xl font-semibold shadow-lg hover:bg-red-700 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                    <span class="material-symbols-outlined">motorcycle</span> <span>Ver Preço & Chamar</span>
                </button>
            </div>

            <!-- Overlay de Confirmação (Tela 2) -->
            <div id="confirmation-overlay" class="overlay hidden">
                <h3 class="text-2xl font-bold mb-4 text-gray-800">Detalhes da Corrida</h3>
                <div class="space-y-2 mb-6 text-gray-700">
                    <p class="flex justify-between">De: <strong id="detalhe-origem" class="font-medium text-right"></strong></p>
                    <p class="flex justify-between">Para: <strong id="detalhe-destino" class="font-medium text-right"></strong></p>
                    <p class="flex justify-between">Distância: <strong id="detalhe-distancia" class="font-medium text-right">0 km</strong></p>
                </div>

                <h2 class="price-estimate text-4xl font-extrabold text-green-600 mb-6 text-center">R$ 0,00</h2>

                <div class="payment-options flex items-center justify-center space-x-2 text-gray-600 bg-gray-100 p-3 rounded-lg mb-6">
                    <span class="material-symbols-outlined">payments</span> <span>PIX / Dinheiro / Cartão</span>
                </div>

                <button id="btn-confirmar"
                    class="w-full primary-button flex items-center justify-center space-x-2 bg-green-600 text-white py-3 rounded-xl font-semibold shadow-lg hover:bg-green-700 transition-all duration-200">
                    Confirmar e Chamar Motorista
                </button>
                <button id="btn-cancelar"
                    class="w-full secondary-button mt-3 bg-gray-200 text-gray-800 py-3 rounded-xl font-semibold hover:bg-gray-300 transition-all duration-200">
                    Cancelar
                </button>
            </div>
            
            <!-- Toast Message for non-intrusive feedback -->
            <div id="toast-message" class="fixed bottom-4 left-1/2 -translate-x-1/2 p-3 bg-gray-800 text-white rounded-lg shadow-xl opacity-0 transition-opacity duration-300 z-[101]">
                Mensagem de feedback aqui.
            </div>

        </main>
    </div>

    <!-- Script principal de inicialização do Google Maps -->
    <script async
        src="https://maps.googleapis.com/maps/api/js?key=&libraries=places&callback=initMap">
    </script>
    
    <script type="module">
        // Importações do Firebase SDK (versão 11.6.1)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, onSnapshot, collection, query, serverTimestamp, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Variáveis Globais de Mapeamento
        let map;
        let directionsService;
        let directionsRenderer;
        let geocoder;
        let originLocation; // Objeto {lat, lng, address}
        let destinationLocation; // Objeto {lat, lng, address}

        // Variáveis Globais do Firebase
        let db;
        let auth;
        let userId = 'loading';
        
        // Configurações e Inicialização do App
        setLogLevel('Debug');
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-mototaxi-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        if (Object.keys(firebaseConfig).length > 0) {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            
            // 1. Configurar Autenticação
            onAuthStateChanged(auth, async (user) => {
                const statusElement = document.getElementById('auth-status');
                if (user) {
                    userId = user.uid;
                    statusElement.textContent = `Usuário logado: ${userId}`;
                    showToast(`Sessão iniciada como ${userId}`);
                    // Opcional: Iniciar o listener de novas corridas
                    setupRideRequestMonitor();
                } else {
                    // Se não houver token inicial, faz login anônimo
                    if (initialAuthToken) {
                        try {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } catch (error) {
                            console.error("Erro ao fazer login com token customizado:", error);
                            await signInAnonymously(auth);
                        }
                    } else {
                        await signInAnonymously(auth);
                    }
                    userId = auth.currentUser?.uid || 'anonimo-nao-logado';
                    statusElement.textContent = `Usuário logado: ${userId}`;
                }
            });
        } else {
            document.getElementById('auth-status').textContent = "Firebase não configurado. Dados não serão salvos.";
        }

        /**
         * Exibe uma mensagem de feedback não intrusiva.
         * @param {string} message A mensagem a ser exibida.
         */
        function showToast(message) {
            const toast = document.getElementById('toast-message');
            toast.textContent = message;
            toast.style.opacity = '1';
            setTimeout(() => {
                toast.style.opacity = '0';
            }, 3000);
        }

        // --- Funções Google Maps ---

        /**
         * Callback chamada pela API do Google Maps para iniciar o mapa.
         */
        window.initMap = function() {
            const defaultLocation = { lat: -23.5505, lng: -46.6333 }; // São Paulo (Exemplo)

            map = new google.maps.Map(document.getElementById('map-simulation'), {
                center: defaultLocation,
                zoom: 12,
                disableDefaultUI: true,
                zoomControl: true,
                streetViewControl: false,
                mapTypeControl: false,
            });

            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer({ map: map, suppressMarkers: true });
            geocoder = new google.maps.Geocoder();

            // Tenta obter a localização real e iniciar os serviços
            getCurrentLocation();
            setupAutocomplete();
        }

        /**
         * Obtém a localização atual do usuário via Geolocation API.
         */
        function getCurrentLocation() {
            const origemInput = document.getElementById('input-origem');
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const pos = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude,
                        };
                        map.setCenter(pos);
                        map.setZoom(16);
                        
                        // Adicionar marcador na localização atual
                        new google.maps.Marker({
                            position: pos,
                            map: map,
                            icon: {
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 8,
                                fillColor: '#22c55e',
                                fillOpacity: 1,
                                strokeColor: '#fff',
                                strokeWeight: 2
                            },
                        });

                        // Geocodifica para obter o endereço
                        geocodeAddress(pos, (address) => {
                            origemInput.value = address;
                            origemInput.readOnly = false;
                            originLocation = { ...pos, address: address };
                        }, "Sua Localização Atual");

                    },
                    () => {
                        handleLocationError(true, origemInput);
                    }
                );
            } else {
                // Navegador não suporta Geolocation
                handleLocationError(false, origemInput);
            }
        }

        /**
         * Trata erros de geolocalização.
         */
        function handleLocationError(browserHasGeolocation, origemInput) {
            origemInput.value = browserHasGeolocation ?
                'Erro: O serviço de localização falhou.' :
                'Erro: Seu navegador não suporta geolocalização.';
            origemInput.readOnly = false;
            showToast("Não foi possível obter sua localização. Defina-a manualmente.");
        }

        /**
         * Configura o Autocomplete (Sugestões de Endereço) nos campos.
         */
        function setupAutocomplete() {
            const destinoInput = document.getElementById('input-destino');
            const origemInput = document.getElementById('input-origem');

            // Autocomplete para Destino
            const autocompleteDestino = new google.maps.places.Autocomplete(destinoInput, {
                componentRestrictions: { country: 'br' },
                fields: ["geometry", "formatted_address", "name"],
            });

            // Autocomplete para Origem (caso o usuário queira mudar a localização atual)
            const autocompleteOrigem = new google.maps.places.Autocomplete(origemInput, {
                componentRestrictions: { country: 'br' },
                fields: ["geometry", "formatted_address", "name"],
            });


            autocompleteDestino.addListener("place_changed", () => {
                const place = autocompleteDestino.getPlace();
                if (place.geometry) {
                    destinationLocation = {
                        lat: place.geometry.location.lat(),
                        lng: place.geometry.location.lng(),
                        address: place.formatted_address || place.name
                    };
                    document.getElementById('btn-chamar').disabled = false;
                } else {
                    document.getElementById('btn-chamar').disabled = true;
                    destinationLocation = null;
                }
            });
            
            autocompleteOrigem.addListener("place_changed", () => {
                const place = autocompleteOrigem.getPlace();
                if (place.geometry) {
                    originLocation = {
                        lat: place.geometry.location.lat(),
                        lng: place.geometry.location.lng(),
                        address: place.formatted_address || place.name
                    };
                    map.setCenter(place.geometry.location);
                } else {
                    originLocation = null;
                }
            });
        }
        
        /**
         * Geocodifica uma posição (lat/lng) para um endereço legível.
         * @param {object} latlng Posição {lat, lng}.
         * @param {function} callback Função a ser chamada com o endereço.
         * @param {string} fallbackAddress Endereço de fallback.
         */
        function geocodeAddress(latlng, callback, fallbackAddress) {
            geocoder.geocode({ location: latlng }, (results, status) => {
                if (status === "OK") {
                    if (results[0]) {
                        callback(results[0].formatted_address);
                    } else {
                        callback(fallbackAddress);
                    }
                } else {
                    console.error("Geocode falhou devido a: " + status);
                    callback(fallbackAddress);
                }
            });
        }


        /**
         * Calcula a rota, exibe no mapa e estima o preço.
         */
        function calculateAndDisplayRoute() {
            if (!originLocation || !destinationLocation) {
                showToast("Por favor, selecione os endereços de origem e destino.");
                return;
            }

            directionsService.route({
                origin: new google.maps.LatLng(originLocation.lat, originLocation.lng),
                destination: new google.maps.LatLng(destinationLocation.lat, destinationLocation.lng),
                travelMode: google.maps.TravelMode.DRIVING, // Usamos DRIVING para rota de mototáxi
            }, (response, status) => {
                if (status === "OK") {
                    directionsRenderer.setDirections(response);
                    
                    const route = response.routes[0].legs[0];
                    const distanceKm = route.distance.value / 1000;
                    const durationMinutes = route.duration.value / 60;
                    
                    // Lógica de Preço (MOCK: Base R$5 + R$2.50/km)
                    const basePrice = 5.00;
                    const pricePerKm = 2.50;
                    const totalPrice = basePrice + (distanceKm * pricePerKm);

                    // Atualizar a tela de confirmação
                    document.getElementById('detalhe-origem').textContent = originLocation.address;
                    document.getElementById('detalhe-destino').textContent = destinationLocation.address;
                    document.getElementById('detalhe-distancia').textContent = `${distanceKm.toFixed(1)} km`;
                    document.querySelector('#confirmation-overlay .price-estimate').textContent = 
                        `R$ ${totalPrice.toFixed(2).replace('.', ',')}`;

                    // Mostrar tela de confirmação
                    document.getElementById('search-overlay').classList.add('hidden');
                    document.getElementById('confirmation-overlay').classList.remove('hidden');

                } else {
                    showToast(`Falha ao calcular rota: ${status}`);
                    directionsRenderer.setDirections({ routes: [] });
                }
            });
        }

        // --- Funções de UI/Eventos ---

        document.getElementById('btn-chamar').addEventListener('click', calculateAndDisplayRoute);
        document.getElementById('btn-cancelar').addEventListener('click', () => {
            document.getElementById('confirmation-overlay').classList.add('hidden');
            document.getElementById('search-overlay').classList.remove('hidden');
            directionsRenderer.setDirections({ routes: [] }); // Limpa a rota no mapa
        });
        document.getElementById('btn-confirmar').addEventListener('click', handleConfirmRide);

        /**
         * Lida com o clique no botão de Confirmar Corrida.
         */
        async function handleConfirmRide() {
            if (!originLocation || !destinationLocation) return;
            
            // Desabilitar o botão para evitar cliques duplicados
            document.getElementById('btn-confirmar').disabled = true;
            document.getElementById('btn-confirmar').textContent = 'Chamando motorista...';

            // Simular o cálculo do preço final
            const priceText = document.querySelector('#confirmation-overlay .price-estimate').textContent;
            const priceValue = parseFloat(priceText.replace('R$', '').replace(',', '.').trim());

            const rideRequest = {
                userId: userId,
                origem: originLocation,
                destino: destinationLocation,
                precoEstimado: priceValue,
                status: 'SOLICITADA',
                timestamp: serverTimestamp()
            };

            try {
                await saveRideRequest(rideRequest);
                
                // Transição para tela de espera (Simulação)
                document.getElementById('confirmation-overlay').classList.add('hidden');
                showToast("Corrida solicitada com sucesso! Aguarde a aceitação do motorista.");
                
                // Resetar inputs e mapa após solicitação (ou ir para tela de rastreamento)
                document.getElementById('input-destino').value = '';
                document.getElementById('btn-chamar').disabled = true;
                directionsRenderer.setDirections({ routes: [] });

            } catch (error) {
                console.error("Erro ao salvar solicitação de corrida:", error);
                showToast("Erro ao solicitar a corrida. Tente novamente.");
            } finally {
                // Reabilitar e restaurar o botão
                document.getElementById('btn-confirmar').disabled = false;
                document.getElementById('btn-confirmar').textContent = 'Confirmar e Chamar Motorista';
                document.getElementById('search-overlay').classList.remove('hidden');
            }
        }
        
        // --- Funções Firestore ---

        /**
         * Salva a solicitação de corrida no Firestore (Acesso Público).
         * @param {object} requestData Os dados da corrida.
         */
        async function saveRideRequest(requestData) {
            if (!db) {
                console.warn("Firestore não está inicializado. Dados não foram salvos.");
                return;
            }

            // O caminho da coleção pública deve ser /artifacts/{appId}/public/data/{collectionName}
            const collectionPath = `artifacts/${appId}/public/data/ride_requests`;
            const ridesCollection = collection(db, collectionPath);
            
            const docRef = await addDoc(ridesCollection, requestData);
            console.log("Solicitação de Corrida salva com ID: ", docRef.id);
            return docRef.id;
        }
        
        /**
         * Monitora o status das corridas do usuário. (Simulação)
         */
        function setupRideRequestMonitor() {
            if (!db || userId === 'loading' || userId === 'anonimo-nao-logado') return;

            const collectionPath = `artifacts/${appId}/public/data/ride_requests`;
            const q = query(
                collection(db, collectionPath),
                // Em um app real, o driver também filtraria por status 'SOLICITADA'
                // Aqui, monitoramos apenas as solicitadas pelo usuário atual para simular o rastreamento.
                where("userId", "==", userId)
            );

            // Ouvinte em tempo real para o status da corrida
            onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    if (change.type === "added" && data.status === 'SOLICITADA') {
                        console.log("Nova solicitação detectada:", data);
                        // showToast("Nova corrida registrada no Firestore.");
                    } else if (change.type === "modified") {
                        if (data.status === 'ACEITA') {
                             showToast("Motorista a caminho! Status: ACEITA.");
                        } else if (data.status === 'CANCELADA') {
                             showToast("Sua corrida foi cancelada.");
                        }
                    }
                });
            }, (error) => {
                console.error("Erro ao monitorar solicitações de corrida:", error);
            });
        }
    </script>
</body>
</html>
